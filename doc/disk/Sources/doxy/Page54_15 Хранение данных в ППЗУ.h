/*! \page page15 Хранение данных в ППЗУ
        В секторе ADDR_DATA_DATA хранится массив структур вида 
    \code
    typedef struct
    {
        uint lastRecord;
        uint addr[MAX_NUM_SAVED_WAVES];
    } ArrayDatas;
    \endcode
        В lastRecord хранится адрес, по которому произведена последняя запись. Если lastRecord равен 0, то массив не соответствует текущему 
    состоянию и нужно смотреть следующий. Значение lastRecord = 0xFFFFFFFF(MAX_UINT) может быть у первого элемента массива, если сохранение 
    данных ещё не производилось. \n
        addr[i] - адрес, по которому записаны данные соответствующего номера в следующем порядке : DataSettings, данные первого канала (если включён), 
    данные второго канала (если включён). Если addr[i] == 0 или addr[i] == MAX_UINT - данных нет. \n\n
    <b>Алгоритм сохранения.</b>
    <OL>
    <LI>
    Проверяем значение lastRecord у нулевого элемента в массиве ADDR_DATA_DATA. Если оно равно 0xFFFFFFFF, переходим к процедуре собственно 
    сохранения данных - шаг 4.</LI>
    <LI>
    Перебираем по порядку элементы массива, пока не находим элемент с lastRecord != 0. Это действующая структура.</LI>
    <LI>
    Записываем в addr[i] 0, что равноценно стиранию данных.</LI>
    <LI>
    Определяем, достаточно ли места в ППЗУ для сохранения данных. Для этого пользуемся размером DataSettings, количеством байта в канале, также 
    значением lastRecord и адресом за последним доступным байном ППЗУ (ADDR_DATA_6 + 128 * 1024). Если места достаточно, переходим к шагу 6.</LI>
    <OL>
    <LI>
    Уплотняем данные. для этого:
    <LI>Заводим в ОЗУ структуру ArrayDatas и копируем в неё действующую.</LI>
    <LI>i = 0; // В этой переменной хранится номер сектора для хранения данных (ADDR_DATA_0 ... ADDR_DATA_6).</LI>
    <LI>if(i > 6) - переход к 5.</LI>
    <LI>Переписываем в ОЗУ.</LI>
    </LI>
    </OL>
    </OL>
*/
